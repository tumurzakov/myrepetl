# Многопоточная архитектура ETL сервиса

## Обзор

Новая многопоточная архитектура решает проблему блокировки источников данных, где только один источник мог быть активен в каждый момент времени. Теперь каждый источник и приемник работают в отдельных потоках, обмениваясь данными через шину сообщений.

## Архитектура

### Компоненты

1. **MessageBus** - Шина сообщений для обмена данными между потоками
2. **SourceThreadService** - Управление потоками источников данных
3. **TargetThreadService** - Управление потоками приемников данных
4. **ThreadManager** - Центральный менеджер жизненного цикла всех потоков
5. **ETLService** - Обновленный основной сервис

### Потоки

- **Source Threads**: Каждый источник данных работает в своем потоке
- **Target Threads**: Каждый приемник данных работает в своем потоке
- **Message Bus Thread**: Обработка сообщений в шине
- **Monitoring Thread**: Мониторинг состояния системы

## Преимущества

### Решение проблемы блокировки
- **Раньше**: Round-robin подход блокировался на `stream.fetchone()`
- **Теперь**: Каждый источник работает независимо в своем потоке

### Параллельная обработка
- Все источники активны одновременно
- События обрабатываются параллельно
- Высокая пропускная способность

### Масштабируемость
- Легко добавлять новые источники и приемники
- Независимое управление жизненным циклом
- Горизонтальное масштабирование

## Использование

### Базовое использование

```python
from src.etl_service import ETLService

# Создание и инициализация сервиса
etl = ETLService()
etl.initialize("configs/demo_pipeline.json")

# Тестирование соединений
if etl.test_connections():
    # Запуск многопоточной репликации
    etl.run_replication()
```

### Управление жизненным циклом

```python
# Graceful shutdown
etl.request_shutdown()

# Получение статистики
stats = etl.thread_manager.get_stats()
print(f"Status: {stats.status.value}")
print(f"Events processed: {stats.total_events_processed}")
```

## Конфигурация

Конфигурация остается той же, что и в оригинальной версии:

```json
{
  "sources": {
    "source1": { ... },
    "source2": { ... }
  },
  "targets": {
    "target1": { ... }
  },
  "mapping": { ... }
}
```

## Мониторинг

### Статистика источников
- Количество обработанных событий
- Количество ошибок
- Время последнего события
- Статус потока

### Статистика приемников
- Количество обработанных событий по типам (INSERT, UPDATE, DELETE)
- Размер очереди событий
- Количество ошибок
- Статус потока

### Статистика шины сообщений
- Количество отправленных сообщений
- Количество обработанных сообщений
- Количество отброшенных сообщений
- Размер очереди

## Синхронизация

### Thread-safe операции
- Все операции с общей памятью защищены блокировками
- Атомарные операции для критических секций
- Безопасная передача данных между потоками

### Управление жизненным циклом
- Graceful shutdown всех потоков
- Обработка сигналов SIGINT и SIGTERM
- Таймауты для остановки потоков

## Обработка ошибок

### Изоляция ошибок
- Ошибка в одном потоке не влияет на другие
- Автоматическое восстановление после ошибок
- Детальное логирование ошибок

### Retry механизмы
- Повторные попытки для сетевых операций
- Обработка временных сбоев
- Fallback стратегии

## Производительность

### Оптимизации
- Неблокирующие операции где возможно
- Эффективная очередь сообщений
- Минимальное копирование данных

### Ресурсы
- Контролируемое потребление памяти
- Настраиваемые размеры очередей
- Мониторинг использования ресурсов

## Отладка

### Логирование
- Структурированные логи с контекстом
- Различные уровни детализации
- Трассировка событий между потоками

### Диагностика
- Статистика в реальном времени
- Проверка состояния потоков
- Анализ производительности

## Миграция

### Обратная совместимость
- Существующие конфигурации работают без изменений
- API остался прежним
- Постепенная миграция

### Изменения
- Новые зависимости для многопоточности
- Дополнительные настройки мониторинга
- Расширенная статистика

## Безопасность

### Thread Safety
- Все операции thread-safe
- Защита от race conditions
- Атомарные операции

### Управление ресурсами
- Контролируемое освобождение ресурсов
- Защита от утечек памяти
- Graceful shutdown

## Примеры использования

### Множественные источники

```python
# Конфигурация с несколькими источниками
{
  "sources": {
    "mysql_source1": { "host": "db1", ... },
    "mysql_source2": { "host": "db2", ... },
    "postgres_source": { "host": "pg1", ... }
  }
}
```

### Множественные приемники

```python
# Конфигурация с несколькими приемниками
{
  "targets": {
    "data_warehouse": { "host": "dw", ... },
    "analytics_db": { "host": "analytics", ... },
    "backup_db": { "host": "backup", ... }
  }
}
```

### Сложные маршрутизации

```python
# События от source1 идут в target1 и target2
# События от source2 идут только в target1
{
  "mapping": {
    "source1.users": {
      "target_table": "target1.users",
      ...
    },
    "source1.orders": {
      "target_table": "target2.orders", 
      ...
    }
  }
}
```

## Заключение

Новая многопоточная архитектура обеспечивает:
- ✅ Параллельную работу всех источников
- ✅ Высокую производительность
- ✅ Масштабируемость
- ✅ Надежность
- ✅ Простоту использования

Проблема блокировки источников полностью решена!

